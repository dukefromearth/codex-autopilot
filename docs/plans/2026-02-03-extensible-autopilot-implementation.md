# Extensible Autopilot Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Refactor the monolithic `codex-autopilot.ts` into a modular architecture with an adapter pattern supporting both Claude SDK and Codex SDK.

**Architecture:** Extract types and pure functions into `src/` modules, create an `AgentAdapter` interface, implement Claude SDK adapter as primary, wrap existing Codex logic as secondary adapter.

**Tech Stack:** TypeScript, Node.js 18+, Claude Agent SDK (`claude-agent-sdk`), tsx for execution.

---

## Task 1: Create Project Structure

**Files:**
- Create: `src/workflow/types.ts`
- Create: `src/adapters/types.ts`
- Create: `src/state/types.ts`
- Create: `src/utils/json.ts`

**Step 1: Create directory structure**

Run:
```bash
mkdir -p src/workflow src/adapters src/state src/utils
```

Expected: Directories created, no output.

**Step 2: Create workflow types**

Create `src/workflow/types.ts`:

```typescript
/**
 * Workflow types for the autopilot runner.
 * A Workflow is a DAG of steps generated by the LLM from a natural language task.
 */

export type Workflow = {
  version: 1;
  id: string;
  name?: string;
  description?: string;
  concurrency?: number;
  steps: WorkflowStep[];
  defaults?: Record<string, unknown>;
};

export type WorkflowStep = {
  id: string;
  type: "agent.run";
  goal: string;
  dependsOn?: string[];
  context?: string;
  adapterRequest?: Record<string, unknown>;
  [key: string]: unknown;
};

export type StepResult = {
  stepId: string;
  status: "succeeded" | "failed" | "skipped";
  sessionId: string;
  outputText: string;
  usage?: { inputTokens: number; outputTokens: number };
  error?: string;
};

export type CompletionCheck =
  | { done: true; summary: string }
  | { done: false; reason: string; nextWorkflow?: Workflow };
```

**Step 3: Create adapter types**

Create `src/adapters/types.ts`:

```typescript
/**
 * Adapter interface for agent execution.
 * Abstracts the differences between Claude SDK and Codex SDK.
 */

export type AdapterName = "claude" | "codex";

export interface ExecuteParams {
  prompt: string;
  cwd: string;
  model?: string;
  options?: Record<string, unknown>;
}

export interface ExecuteResult {
  sessionId: string;
  outputText: string;
  status: "succeeded" | "failed";
  usage?: { inputTokens: number; outputTokens: number };
}

export interface AgentAdapter {
  readonly name: AdapterName;
  execute(params: ExecuteParams): Promise<ExecuteResult>;
  resume(
    sessionId: string,
    prompt: string,
    params?: Partial<ExecuteParams>
  ): Promise<ExecuteResult>;
}
```

**Step 4: Create state types**

Create `src/state/types.ts`:

```typescript
/**
 * State and manifest types for run persistence.
 */

import type { Workflow, StepResult, CompletionCheck } from "../workflow/types.js";

export type RunOptions = {
  adapter: "claude" | "codex";
  model: string;
  concurrency: number;
  maxIterations: number;
  unsafe: boolean;
};

export type ExecArtifacts = {
  promptTxt: string;
  outputTxt: string;
  metadataJson: string;
};

export type ExecEntry = {
  execId: string;
  label: string;
  sessionId: string;
  status: "succeeded" | "failed";
  startedAt: string;
  finishedAt: string;
  artifacts: ExecArtifacts;
};

export type GraphNode = {
  id: string;
  type: "exec";
  execId: string;
  label: string;
  sessionId: string;
};

export type GraphEdge = {
  type: "dependsOn" | "invokes";
  from: string;
  to: string;
};

export type RunManifest = {
  runId: string;
  startedAt: string;
  finishedAt?: string;
  cwd: string;
  options: RunOptions;
  execs: ExecEntry[];
  graph: {
    nodes: GraphNode[];
    edges: GraphEdge[];
    warnings: string[];
  };
};

export type RunState = {
  task: string;
  options: RunOptions;
  iterations: Array<{
    index: number;
    workflow: Workflow;
    steps: StepResult[];
    completion: CompletionCheck;
  }>;
};

export type RunContext = {
  runId: string;
  runDir: string;
  task: string;
  cwd: string;
  options: RunOptions;
  nextExecIndex: number;
};
```

**Step 5: Create JSON utility**

Create `src/utils/json.ts`:

```typescript
/**
 * Safe JSON parsing utilities.
 */

/**
 * Safely parse JSON, returning null on failure.
 * Attempts to extract JSON from prose-wrapped output.
 */
export function safeJsonParse(text: string): unknown | null {
  const trimmed = text.trim();
  if (!trimmed) return null;

  try {
    return JSON.parse(trimmed);
  } catch {
    // Try extracting JSON from prose
    const start = trimmed.indexOf("{");
    const end = trimmed.lastIndexOf("}");
    if (start === -1 || end === -1 || end <= start) {
      return null;
    }
    const slice = trimmed.slice(start, end + 1);
    try {
      return JSON.parse(slice);
    } catch {
      return null;
    }
  }
}

/**
 * Truncate text with head/tail preservation.
 */
export function truncate(text: string, maxChars: number): string {
  if (text.length <= maxChars) return text;
  const head = text.slice(0, Math.floor(maxChars * 0.7));
  const tail = text.slice(-Math.floor(maxChars * 0.3));
  return `${head}\n\n...(truncated ${text.length - maxChars} chars)...\n\n${tail}`;
}
```

**Step 6: Run typecheck**

Run: `npm run typecheck`
Expected: Pass with no errors.

**Step 7: Commit**

```bash
git add src/
git commit -m "feat: add core type definitions for extensible autopilot

- src/workflow/types.ts: Workflow, WorkflowStep, StepResult, CompletionCheck
- src/adapters/types.ts: AgentAdapter interface, ExecuteParams, ExecuteResult
- src/state/types.ts: RunManifest, RunState, RunContext
- src/utils/json.ts: safeJsonParse, truncate utilities"
```

---

## Task 2: Workflow Parser and Validator

**Files:**
- Create: `src/workflow/parser.ts`
- Create: `tests/workflow.test.ts`

**Step 1: Write failing tests for workflow parser**

Create `tests/workflow.test.ts`:

```typescript
import { describe, it } from "node:test";
import assert from "node:assert";
import { parseWorkflow } from "../src/workflow/parser.js";

describe("parseWorkflow", () => {
  it("parses valid workflow JSON", () => {
    const input = JSON.stringify({
      version: 1,
      id: "test-workflow",
      steps: [
        { id: "step1", type: "agent.run", goal: "do something" },
      ],
    });
    const workflow = parseWorkflow(input);
    assert.strictEqual(workflow.id, "test-workflow");
    assert.strictEqual(workflow.steps.length, 1);
    assert.strictEqual(workflow.steps[0].id, "step1");
  });

  it("extracts JSON from prose-wrapped output", () => {
    const input = `Here's the workflow:
{"version":1,"id":"extracted","steps":[{"id":"a","type":"agent.run","goal":"test"}]}
Let me know if you need changes.`;
    const workflow = parseWorkflow(input);
    assert.strictEqual(workflow.id, "extracted");
  });

  it("throws on invalid JSON", () => {
    assert.throws(() => parseWorkflow("not json"), /invalid json/i);
  });

  it("throws on missing version", () => {
    const input = JSON.stringify({ id: "no-version", steps: [] });
    assert.throws(() => parseWorkflow(input), /version must be 1/i);
  });

  it("throws on missing steps", () => {
    const input = JSON.stringify({ version: 1, id: "no-steps" });
    assert.throws(() => parseWorkflow(input), /steps must be an array/i);
  });

  it("throws on step without goal", () => {
    const input = JSON.stringify({
      version: 1,
      id: "bad-step",
      steps: [{ id: "s1", type: "agent.run" }],
    });
    assert.throws(() => parseWorkflow(input), /missing goal/i);
  });

  it("normalizes step IDs when missing", () => {
    const input = JSON.stringify({
      version: 1,
      id: "auto-ids",
      steps: [
        { type: "agent.run", goal: "first" },
        { type: "agent.run", goal: "second" },
      ],
    });
    const workflow = parseWorkflow(input);
    assert.strictEqual(workflow.steps[0].id, "step-1");
    assert.strictEqual(workflow.steps[1].id, "step-2");
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm test`
Expected: FAIL - Cannot find module '../src/workflow/parser.js'

**Step 3: Implement workflow parser**

Create `src/workflow/parser.ts`:

```typescript
/**
 * Parse and validate workflow JSON from LLM output.
 */

import type { Workflow, WorkflowStep } from "./types.js";
import { safeJsonParse } from "../utils/json.js";

export class WorkflowParseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "WorkflowParseError";
  }
}

/**
 * Parse workflow JSON from text, extracting from prose if needed.
 */
export function parseWorkflow(text: string): Workflow {
  const parsed = safeJsonParse(text);
  if (!parsed) {
    throw new WorkflowParseError("Invalid JSON: could not parse workflow");
  }
  return normalizeWorkflow(parsed);
}

/**
 * Validate and normalize a parsed workflow object.
 */
export function normalizeWorkflow(value: unknown): Workflow {
  if (!value || typeof value !== "object") {
    throw new WorkflowParseError("Workflow must be an object");
  }

  const obj = value as Record<string, unknown>;

  if (obj.version !== 1) {
    throw new WorkflowParseError("Workflow.version must be 1");
  }

  if (typeof obj.id !== "string" || !obj.id.trim()) {
    throw new WorkflowParseError("Workflow.id must be a non-empty string");
  }

  if (!Array.isArray(obj.steps)) {
    throw new WorkflowParseError("Workflow.steps must be an array");
  }

  const steps = obj.steps.map((raw, index) => normalizeStep(raw, index));

  return {
    version: 1,
    id: obj.id.trim(),
    name: typeof obj.name === "string" ? obj.name : undefined,
    description: typeof obj.description === "string" ? obj.description : undefined,
    concurrency:
      typeof obj.concurrency === "number" && Number.isFinite(obj.concurrency)
        ? Math.max(1, Math.floor(obj.concurrency))
        : undefined,
    defaults:
      typeof obj.defaults === "object" && obj.defaults !== null
        ? (obj.defaults as Record<string, unknown>)
        : undefined,
    steps,
  };
}

function normalizeStep(raw: unknown, index: number): WorkflowStep {
  if (!raw || typeof raw !== "object") {
    throw new WorkflowParseError(`Step ${index + 1} must be an object`);
  }

  const step = raw as Record<string, unknown>;
  const id =
    typeof step.id === "string" && step.id.trim()
      ? step.id.trim()
      : `step-${index + 1}`;

  if (step.type !== "agent.run") {
    throw new WorkflowParseError(
      `Step "${id}" has unsupported type "${String(step.type)}"`
    );
  }

  const goal = typeof step.goal === "string" ? step.goal : "";
  if (!goal.trim()) {
    throw new WorkflowParseError(`Step "${id}" is missing goal`);
  }

  const dependsOn = Array.isArray(step.dependsOn)
    ? step.dependsOn.map((dep) => String(dep).trim()).filter(Boolean)
    : undefined;

  return {
    ...step,
    id,
    type: "agent.run",
    goal,
    dependsOn,
    context: typeof step.context === "string" ? step.context : undefined,
    adapterRequest:
      typeof step.adapterRequest === "object" && step.adapterRequest !== null
        ? (step.adapterRequest as Record<string, unknown>)
        : undefined,
  };
}
```

**Step 4: Run tests to verify they pass**

Run: `npm test`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add src/workflow/parser.ts tests/workflow.test.ts
git commit -m "feat: add workflow parser with validation

- parseWorkflow() extracts and validates workflow JSON
- normalizeWorkflow() ensures consistent structure
- Handles prose-wrapped output from LLMs
- Full test coverage for parsing and error cases"
```

---

## Task 3: Prompt Builder

**Files:**
- Create: `src/workflow/prompt.ts`
- Modify: `tests/workflow.test.ts`

**Step 1: Add failing tests for prompt builder**

Append to `tests/workflow.test.ts`:

```typescript
import { buildStepPrompt, buildWorkflowGenPrompt, buildCompletionCheckPrompt } from "../src/workflow/prompt.js";
import type { StepResult } from "../src/workflow/types.js";

describe("buildStepPrompt", () => {
  it("includes step goal and task", () => {
    const prompt = buildStepPrompt(
      { id: "impl", type: "agent.run", goal: "use the task-executor skill. Fix the bug." },
      new Map(),
      "Fix authentication bug"
    );
    assert.ok(prompt.includes("use the task-executor skill. Fix the bug."));
    assert.ok(prompt.includes("Overall task: Fix authentication bug"));
  });

  it("includes dependency outputs", () => {
    const completed = new Map<string, StepResult>([
      ["research", {
        stepId: "research",
        status: "succeeded",
        sessionId: "sess-1",
        outputText: "Found the issue in auth.ts line 42",
      }],
    ]);
    const prompt = buildStepPrompt(
      { id: "impl", type: "agent.run", goal: "implement fix", dependsOn: ["research"] },
      completed,
      "Fix bug"
    );
    assert.ok(prompt.includes("--- research (succeeded) ---"));
    assert.ok(prompt.includes("Found the issue in auth.ts line 42"));
  });

  it("handles empty dependency output", () => {
    const completed = new Map<string, StepResult>([
      ["empty", { stepId: "empty", status: "succeeded", sessionId: "s", outputText: "" }],
    ]);
    const prompt = buildStepPrompt(
      { id: "next", type: "agent.run", goal: "continue", dependsOn: ["empty"] },
      completed,
      "task"
    );
    assert.ok(prompt.includes("(empty)"));
  });
});

describe("buildWorkflowGenPrompt", () => {
  it("includes task and iteration", () => {
    const prompt = buildWorkflowGenPrompt("Build a feature", 1, "");
    assert.ok(prompt.includes("use the workflow-generator skill"));
    assert.ok(prompt.includes("Task: Build a feature"));
    assert.ok(prompt.includes("Iteration: 1"));
  });

  it("includes carry summary when provided", () => {
    const prompt = buildWorkflowGenPrompt("task", 2, "Previous: step1 failed");
    assert.ok(prompt.includes("Context from previous iterations:"));
    assert.ok(prompt.includes("Previous: step1 failed"));
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm test`
Expected: FAIL - Cannot find module '../src/workflow/prompt.js'

**Step 3: Implement prompt builder**

Create `src/workflow/prompt.ts`:

```typescript
/**
 * Prompt construction for workflow generation and step execution.
 */

import type { WorkflowStep, StepResult, Workflow, CompletionCheck } from "./types.js";
import { truncate } from "../utils/json.js";

/**
 * Build prompt for a workflow step execution.
 */
export function buildStepPrompt(
  step: WorkflowStep,
  completed: Map<string, StepResult>,
  task: string
): string {
  const blocks: string[] = [];

  blocks.push(step.goal.trim());
  blocks.push("");
  blocks.push(`Overall task: ${task}`);

  const deps = (step.dependsOn ?? [])
    .map((depId) => completed.get(depId))
    .filter((dep): dep is StepResult => dep !== undefined);

  if (deps.length > 0) {
    blocks.push("");
    blocks.push("Dependency outputs:");
    for (const dep of deps) {
      blocks.push(`\n--- ${dep.stepId} (${dep.status}) ---\n`);
      blocks.push(dep.outputText || "(empty)");
    }
  }

  if (typeof step.context === "string" && step.context.trim()) {
    blocks.push("");
    blocks.push("Additional context:");
    blocks.push(step.context.trim());
  }

  blocks.push("");
  blocks.push("If you make code changes, run the most relevant checks/tests and report results.");
  blocks.push("Finish with a short 'Done' summary and any remaining risks.");

  return blocks.join("\n");
}

/**
 * Build prompt for workflow generation.
 */
export function buildWorkflowGenPrompt(
  task: string,
  iteration: number,
  carrySummary: string
): string {
  const parts: string[] = [];

  parts.push("use the workflow-generator skill.");
  parts.push("");
  parts.push(`Task: ${task}`);

  if (carrySummary.trim()) {
    parts.push("");
    parts.push("Context from previous iterations:");
    parts.push(carrySummary);
  }

  parts.push("");
  parts.push("Output ONLY valid JSON for a workflow object with fields:");
  parts.push("- version (1)");
  parts.push("- id (string)");
  parts.push('- steps: array of { id, type:"agent.run", goal, dependsOn? }');
  parts.push("");
  parts.push("Rules:");
  parts.push('- Keep it small (<= 8 steps). Prefer parallel research → execute → verify → summarize.');
  parts.push('- Every step.goal MUST begin with: "use the <skill> skill."');
  parts.push("- Use only skills that exist in this workspace.");
  parts.push("- Use dependsOn to express data dependencies.");
  parts.push("- If iteration > 1, focus only on remaining work (do not repeat completed steps).");
  parts.push("");
  parts.push(`Iteration: ${iteration}`);

  return parts.join("\n");
}

/**
 * Build prompt for completion check.
 */
export function buildCompletionCheckPrompt(
  task: string,
  workflow: Workflow,
  results: StepResult[],
  iteration: number
): string {
  const condensed = results.map((r) => ({
    stepId: r.stepId,
    status: r.status,
    sessionId: r.sessionId,
    output: truncate(r.outputText, 18_000),
    error: r.error,
  }));

  const parts: string[] = [];

  parts.push("use the reviewer skill.");
  parts.push("");
  parts.push(`Task: ${task}`);
  parts.push(`Iteration: ${iteration}`);
  parts.push("");
  parts.push("Here are the workflow results (JSON):");
  parts.push(JSON.stringify({ workflowId: workflow.id, results: condensed }, null, 2));
  parts.push("");
  parts.push("Return JSON ONLY with one of these shapes:");
  parts.push('1) {"done":true,"summary":"..."}');
  parts.push('2) {"done":false,"reason":"...","nextWorkflow":{...workflow json...}}');
  parts.push("");
  parts.push("Rules:");
  parts.push("- Be strict: done=true only if the task is actually completed.");
  parts.push("- If not done, provide a small nextWorkflow (<= 6 steps) that finishes the remaining work.");
  parts.push('- nextWorkflow steps should begin with: "use the <skill> skill."');

  return parts.join("\n");
}

/**
 * Build carry summary for next iteration.
 */
export function buildCarrySummary(
  workflow: Workflow,
  results: StepResult[],
  completion: CompletionCheck
): string {
  const lines: string[] = [];

  lines.push(`Previous workflow: ${workflow.id}`);
  lines.push("Step statuses:");

  for (const r of results) {
    lines.push(`- ${r.stepId}: ${r.status} (session ${r.sessionId})`);
    if (r.error) {
      lines.push(`  error: ${r.error}`);
    }
  }

  if (!completion.done) {
    lines.push(`Reviewer: not done (${completion.reason})`);
  }

  return lines.join("\n");
}
```

**Step 4: Run tests to verify they pass**

Run: `npm test`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add src/workflow/prompt.ts tests/workflow.test.ts
git commit -m "feat: add prompt builders for workflow execution

- buildStepPrompt() constructs step execution prompts with deps
- buildWorkflowGenPrompt() constructs workflow generation prompts
- buildCompletionCheckPrompt() constructs reviewer prompts
- buildCarrySummary() formats iteration context"
```

---

## Task 4: Dependency Resolution

**Files:**
- Create: `src/workflow/executor.ts`
- Modify: `tests/workflow.test.ts`

**Step 1: Add failing tests for dependency resolution**

Append to `tests/workflow.test.ts`:

```typescript
import { resolveDependencyOrder, detectCycle } from "../src/workflow/executor.js";

describe("resolveDependencyOrder", () => {
  it("returns steps with no deps first", () => {
    const steps = [
      { id: "b", type: "agent.run" as const, goal: "b", dependsOn: ["a"] },
      { id: "a", type: "agent.run" as const, goal: "a" },
    ];
    const waves = resolveDependencyOrder(steps);
    assert.strictEqual(waves[0][0].id, "a");
    assert.strictEqual(waves[1][0].id, "b");
  });

  it("groups parallel steps in same wave", () => {
    const steps = [
      { id: "a", type: "agent.run" as const, goal: "a" },
      { id: "b", type: "agent.run" as const, goal: "b" },
      { id: "c", type: "agent.run" as const, goal: "c", dependsOn: ["a", "b"] },
    ];
    const waves = resolveDependencyOrder(steps);
    assert.strictEqual(waves[0].length, 2); // a and b parallel
    assert.strictEqual(waves[1].length, 1); // c after
  });

  it("throws on circular dependency", () => {
    const steps = [
      { id: "a", type: "agent.run" as const, goal: "a", dependsOn: ["b"] },
      { id: "b", type: "agent.run" as const, goal: "b", dependsOn: ["a"] },
    ];
    assert.throws(() => resolveDependencyOrder(steps), /circular/i);
  });
});

describe("detectCycle", () => {
  it("returns null for valid DAG", () => {
    const steps = [
      { id: "a", type: "agent.run" as const, goal: "a" },
      { id: "b", type: "agent.run" as const, goal: "b", dependsOn: ["a"] },
    ];
    assert.strictEqual(detectCycle(steps), null);
  });

  it("returns cycle path for circular deps", () => {
    const steps = [
      { id: "a", type: "agent.run" as const, goal: "a", dependsOn: ["c"] },
      { id: "b", type: "agent.run" as const, goal: "b", dependsOn: ["a"] },
      { id: "c", type: "agent.run" as const, goal: "c", dependsOn: ["b"] },
    ];
    const cycle = detectCycle(steps);
    assert.ok(cycle !== null);
    assert.ok(cycle.length >= 2);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm test`
Expected: FAIL - Cannot find module '../src/workflow/executor.js'

**Step 3: Implement dependency resolution**

Create `src/workflow/executor.ts`:

```typescript
/**
 * Workflow execution utilities.
 */

import type { WorkflowStep, StepResult } from "./types.js";

/**
 * Resolve workflow steps into execution waves (parallel groups).
 * Throws if circular dependencies are detected.
 */
export function resolveDependencyOrder(steps: WorkflowStep[]): WorkflowStep[][] {
  const cycle = detectCycle(steps);
  if (cycle) {
    throw new Error(`Circular dependency detected: ${cycle.join(" → ")}`);
  }

  const byId = new Map(steps.map((s) => [s.id, s]));
  const completed = new Set<string>();
  const waves: WorkflowStep[][] = [];

  while (completed.size < steps.length) {
    const ready = steps.filter(
      (step) =>
        !completed.has(step.id) &&
        (step.dependsOn ?? []).every((dep) => completed.has(dep))
    );

    if (ready.length === 0) {
      const remaining = steps
        .filter((s) => !completed.has(s.id))
        .map((s) => s.id);
      throw new Error(`Workflow stuck: cannot resolve ${remaining.join(", ")}`);
    }

    waves.push(ready);
    for (const step of ready) {
      completed.add(step.id);
    }
  }

  return waves;
}

/**
 * Detect circular dependencies in workflow steps.
 * Returns the cycle path if found, null otherwise.
 */
export function detectCycle(steps: WorkflowStep[]): string[] | null {
  const byId = new Map(steps.map((s) => [s.id, s]));
  const visited = new Set<string>();
  const inStack = new Set<string>();
  const path: string[] = [];

  function dfs(id: string): string[] | null {
    if (inStack.has(id)) {
      const cycleStart = path.indexOf(id);
      return [...path.slice(cycleStart), id];
    }
    if (visited.has(id)) {
      return null;
    }

    visited.add(id);
    inStack.add(id);
    path.push(id);

    const step = byId.get(id);
    if (step) {
      for (const dep of step.dependsOn ?? []) {
        const cycle = dfs(dep);
        if (cycle) return cycle;
      }
    }

    path.pop();
    inStack.delete(id);
    return null;
  }

  for (const step of steps) {
    const cycle = dfs(step.id);
    if (cycle) return cycle;
  }

  return null;
}

/**
 * Find steps that are ready to execute (all deps satisfied).
 */
export function findReadySteps(
  steps: WorkflowStep[],
  completed: Set<string>,
  running: Set<string>
): WorkflowStep[] {
  return steps.filter(
    (step) =>
      !completed.has(step.id) &&
      !running.has(step.id) &&
      (step.dependsOn ?? []).every((dep) => completed.has(dep))
  );
}
```

**Step 4: Run tests to verify they pass**

Run: `npm test`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add src/workflow/executor.ts tests/workflow.test.ts
git commit -m "feat: add workflow dependency resolution

- resolveDependencyOrder() groups steps into parallel waves
- detectCycle() finds circular dependencies
- findReadySteps() identifies executable steps"
```

---

## Task 5: Adapter Interface and Factory

**Files:**
- Create: `src/adapters/factory.ts`
- Create: `src/adapters/mock.ts`
- Create: `tests/adapters.test.ts`

**Step 1: Create mock adapter for testing**

Create `src/adapters/mock.ts`:

```typescript
/**
 * Mock adapter for testing.
 */

import type { AgentAdapter, ExecuteParams, ExecuteResult } from "./types.js";

export type MockResponse = {
  sessionId: string;
  outputText: string;
  status: "succeeded" | "failed";
  usage?: { inputTokens: number; outputTokens: number };
};

/**
 * Mock adapter that returns predefined responses.
 */
export class MockAdapter implements AgentAdapter {
  readonly name = "claude" as const;
  private responses: MockResponse[];
  private callIndex = 0;
  public calls: ExecuteParams[] = [];

  constructor(responses: MockResponse[]) {
    this.responses = responses;
  }

  async execute(params: ExecuteParams): Promise<ExecuteResult> {
    this.calls.push(params);
    const response = this.responses[this.callIndex] ?? {
      sessionId: `mock-session-${this.callIndex}`,
      outputText: "Mock response",
      status: "succeeded" as const,
    };
    this.callIndex++;
    return response;
  }

  async resume(
    sessionId: string,
    prompt: string,
    params?: Partial<ExecuteParams>
  ): Promise<ExecuteResult> {
    return this.execute({
      prompt,
      cwd: params?.cwd ?? process.cwd(),
      ...params,
    });
  }
}
```

**Step 2: Create adapter factory**

Create `src/adapters/factory.ts`:

```typescript
/**
 * Adapter factory.
 */

import type { AgentAdapter, AdapterName } from "./types.js";

/**
 * Create an adapter by name.
 * Throws if adapter is not available.
 */
export async function createAdapter(name: AdapterName): Promise<AgentAdapter> {
  switch (name) {
    case "claude": {
      const { ClaudeAdapter } = await import("./claude.js");
      return new ClaudeAdapter();
    }
    case "codex": {
      const { CodexAdapter } = await import("./codex.js");
      return new CodexAdapter();
    }
    default:
      throw new Error(`Unknown adapter: ${name}`);
  }
}
```

**Step 3: Write adapter contract tests**

Create `tests/adapters.test.ts`:

```typescript
import { describe, it } from "node:test";
import assert from "node:assert";
import { MockAdapter } from "../src/adapters/mock.js";

describe("MockAdapter", () => {
  it("returns predefined responses in order", async () => {
    const adapter = new MockAdapter([
      { sessionId: "s1", outputText: "first", status: "succeeded" },
      { sessionId: "s2", outputText: "second", status: "succeeded" },
    ]);

    const r1 = await adapter.execute({ prompt: "p1", cwd: "/" });
    const r2 = await adapter.execute({ prompt: "p2", cwd: "/" });

    assert.strictEqual(r1.outputText, "first");
    assert.strictEqual(r2.outputText, "second");
  });

  it("records all calls", async () => {
    const adapter = new MockAdapter([
      { sessionId: "s", outputText: "out", status: "succeeded" },
    ]);

    await adapter.execute({ prompt: "test prompt", cwd: "/test" });

    assert.strictEqual(adapter.calls.length, 1);
    assert.strictEqual(adapter.calls[0].prompt, "test prompt");
    assert.strictEqual(adapter.calls[0].cwd, "/test");
  });

  it("implements AgentAdapter interface", async () => {
    const adapter = new MockAdapter([
      { sessionId: "s", outputText: "out", status: "succeeded" },
    ]);

    // Verify interface
    assert.strictEqual(adapter.name, "claude");
    assert.strictEqual(typeof adapter.execute, "function");
    assert.strictEqual(typeof adapter.resume, "function");
  });
});
```

**Step 4: Run tests to verify they pass**

Run: `npm test`
Expected: All tests pass (mock adapter tests).

**Step 5: Commit**

```bash
git add src/adapters/mock.ts src/adapters/factory.ts tests/adapters.test.ts
git commit -m "feat: add adapter factory and mock adapter

- MockAdapter for testing without real LLM calls
- createAdapter() factory for dynamic adapter loading
- Adapter contract tests"
```

---

## Task 6: Claude Adapter (Stub)

**Files:**
- Create: `src/adapters/claude.ts`
- Modify: `tests/adapters.test.ts`

**Step 1: Create Claude adapter stub**

Create `src/adapters/claude.ts`:

```typescript
/**
 * Claude SDK adapter.
 *
 * This adapter uses the Claude Agent SDK to execute prompts.
 * Skills are loaded via settingSources: ["project"].
 */

import type { AgentAdapter, ExecuteParams, ExecuteResult } from "./types.js";

export class ClaudeAdapter implements AgentAdapter {
  readonly name = "claude" as const;

  async execute(params: ExecuteParams): Promise<ExecuteResult> {
    // TODO: Implement with real Claude Agent SDK
    // For now, throw to indicate not yet implemented
    throw new Error(
      "ClaudeAdapter.execute() not yet implemented. " +
      "Install claude-agent-sdk and implement the query() integration."
    );
  }

  async resume(
    sessionId: string,
    prompt: string,
    params?: Partial<ExecuteParams>
  ): Promise<ExecuteResult> {
    // Resume is execute with resume option
    return this.execute({
      prompt,
      cwd: params?.cwd ?? process.cwd(),
      ...params,
      options: {
        ...params?.options,
        resume: sessionId,
      },
    });
  }
}
```

**Step 2: Create Codex adapter stub**

Create `src/adapters/codex.ts`:

```typescript
/**
 * Codex SDK adapter.
 *
 * This adapter wraps the existing Codex CLI execution logic.
 * To be implemented by extracting from examples/codex-autopilot.ts.
 */

import type { AgentAdapter, ExecuteParams, ExecuteResult } from "./types.js";

export class CodexAdapter implements AgentAdapter {
  readonly name = "codex" as const;

  async execute(params: ExecuteParams): Promise<ExecuteResult> {
    // TODO: Extract from examples/codex-autopilot.ts codexExec()
    throw new Error(
      "CodexAdapter.execute() not yet implemented. " +
      "Extract codexExec() logic from examples/codex-autopilot.ts."
    );
  }

  async resume(
    sessionId: string,
    prompt: string,
    params?: Partial<ExecuteParams>
  ): Promise<ExecuteResult> {
    return this.execute({
      prompt,
      cwd: params?.cwd ?? process.cwd(),
      ...params,
      options: {
        ...params?.options,
        resumeThreadId: sessionId,
      },
    });
  }
}
```

**Step 3: Run typecheck**

Run: `npm run typecheck`
Expected: Pass.

**Step 4: Commit**

```bash
git add src/adapters/claude.ts src/adapters/codex.ts
git commit -m "feat: add Claude and Codex adapter stubs

- ClaudeAdapter stub for Claude Agent SDK integration
- CodexAdapter stub for Codex CLI wrapping
- Both throw NotImplemented until SDK integration is added"
```

---

## Task 7: State Management

**Files:**
- Create: `src/state/artifacts.ts`
- Create: `src/state/manifest.ts`

**Step 1: Create artifacts writer**

Create `src/state/artifacts.ts`:

```typescript
/**
 * Per-execution artifact writing.
 */

import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";
import type { RunContext, ExecEntry, ExecArtifacts } from "./types.js";

/**
 * Allocate the next execution ID.
 */
export function allocateExecId(context: RunContext): string {
  const id = `exec-${String(context.nextExecIndex).padStart(3, "0")}`;
  context.nextExecIndex++;
  return id;
}

/**
 * Create execution directory and write artifacts.
 */
export async function writeExecArtifacts(
  context: RunContext,
  execId: string,
  label: string,
  prompt: string,
  output: string,
  metadata: Record<string, unknown>
): Promise<ExecArtifacts> {
  const safeLabel = label
    .toLowerCase()
    .replace(/[^a-z0-9-_]+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "") || "exec";

  const execDir = path.join(context.runDir, `${execId}-${safeLabel}`);
  await mkdir(execDir, { recursive: true });

  const promptPath = path.join(execDir, "prompt.txt");
  const outputPath = path.join(execDir, "output.txt");
  const metadataPath = path.join(execDir, "metadata.json");

  await Promise.all([
    writeFile(promptPath, prompt, "utf8"),
    writeFile(outputPath, output, "utf8"),
    writeFile(metadataPath, JSON.stringify(metadata, null, 2), "utf8"),
  ]);

  return {
    promptTxt: path.relative(context.runDir, promptPath),
    outputTxt: path.relative(context.runDir, outputPath),
    metadataJson: path.relative(context.runDir, metadataPath),
  };
}

/**
 * Create an ExecEntry from execution results.
 */
export function createExecEntry(
  execId: string,
  label: string,
  sessionId: string,
  status: "succeeded" | "failed",
  startedAt: string,
  finishedAt: string,
  artifacts: ExecArtifacts
): ExecEntry {
  return {
    execId,
    label,
    sessionId,
    status,
    startedAt,
    finishedAt,
    artifacts,
  };
}
```

**Step 2: Create manifest writer**

Create `src/state/manifest.ts`:

```typescript
/**
 * Run manifest management.
 */

import { mkdir, writeFile } from "node:fs/promises";
import path from "node:path";
import type { RunManifest, RunContext, RunOptions, ExecEntry, GraphNode, GraphEdge } from "./types.js";

/**
 * Initialize a new run context.
 */
export async function initializeRun(
  task: string,
  options: RunOptions,
  outDir: string
): Promise<{ context: RunContext; manifest: RunManifest }> {
  const runId = `autopilot-${new Date().toISOString().replace(/[:.]/g, "-")}`;
  const runDir = path.join(outDir, runId);
  await mkdir(runDir, { recursive: true });

  const manifest: RunManifest = {
    runId,
    startedAt: new Date().toISOString(),
    cwd: process.cwd(),
    options,
    execs: [],
    graph: {
      nodes: [],
      edges: [],
      warnings: [],
    },
  };

  const context: RunContext = {
    runId,
    runDir,
    task,
    cwd: process.cwd(),
    options,
    nextExecIndex: 1,
  };

  await writeManifest(context, manifest);

  return { context, manifest };
}

/**
 * Write manifest to disk.
 */
export async function writeManifest(
  context: RunContext,
  manifest: RunManifest
): Promise<void> {
  const manifestPath = path.join(context.runDir, "manifest.json");
  await writeFile(manifestPath, JSON.stringify(manifest, null, 2), "utf8");
}

/**
 * Add an exec entry to the manifest.
 */
export function addExecToManifest(
  manifest: RunManifest,
  entry: ExecEntry
): void {
  manifest.execs.push(entry);

  // Add graph node
  const node: GraphNode = {
    id: `exec:${entry.execId}`,
    type: "exec",
    execId: entry.execId,
    label: entry.label,
    sessionId: entry.sessionId,
  };
  manifest.graph.nodes.push(node);
}

/**
 * Add a dependency edge to the manifest graph.
 */
export function addDependsOnEdge(
  manifest: RunManifest,
  fromExecId: string,
  toExecId: string
): void {
  manifest.graph.edges.push({
    type: "dependsOn",
    from: `exec:${fromExecId}`,
    to: `exec:${toExecId}`,
  });
}

/**
 * Add an invokes edge to the manifest graph.
 */
export function addInvokesEdge(
  manifest: RunManifest,
  fromExecId: string,
  toExecId: string
): void {
  manifest.graph.edges.push({
    type: "invokes",
    from: `exec:${fromExecId}`,
    to: `exec:${toExecId}`,
  });
}

/**
 * Add a warning to the manifest.
 */
export function addWarning(manifest: RunManifest, message: string): void {
  manifest.graph.warnings.push(message);
}

/**
 * Finalize the run.
 */
export function finalizeRun(manifest: RunManifest): void {
  manifest.finishedAt = new Date().toISOString();
}
```

**Step 3: Run typecheck**

Run: `npm run typecheck`
Expected: Pass.

**Step 4: Commit**

```bash
git add src/state/artifacts.ts src/state/manifest.ts
git commit -m "feat: add state management for run persistence

- artifacts.ts: write per-exec prompt/output/metadata
- manifest.ts: initialize runs, track execs, build graph
- All state persisted to runs/autopilot/{run-id}/"
```

---

## Task 8: Main Runner

**Files:**
- Create: `src/runner.ts`

**Step 1: Create main runner**

Create `src/runner.ts`:

```typescript
/**
 * Main autopilot runner.
 *
 * Orchestrates workflow generation, execution, and completion checking.
 */

import type { AgentAdapter } from "./adapters/types.js";
import type { Workflow, StepResult, CompletionCheck } from "./workflow/types.js";
import type { RunManifest, RunContext, RunOptions, RunState } from "./state/types.js";
import { parseWorkflow, normalizeWorkflow } from "./workflow/parser.js";
import {
  buildStepPrompt,
  buildWorkflowGenPrompt,
  buildCompletionCheckPrompt,
  buildCarrySummary,
} from "./workflow/prompt.js";
import { findReadySteps } from "./workflow/executor.js";
import { safeJsonParse } from "./utils/json.js";
import {
  initializeRun,
  writeManifest,
  addExecToManifest,
  addDependsOnEdge,
  addInvokesEdge,
  finalizeRun,
} from "./state/manifest.js";
import {
  allocateExecId,
  writeExecArtifacts,
  createExecEntry,
} from "./state/artifacts.js";
import { writeFile } from "node:fs/promises";
import path from "node:path";

export interface RunnerParams {
  task: string;
  adapter: AgentAdapter;
  options: RunOptions;
  outDir: string;
}

export interface RunnerResult {
  status: "completed" | "max-iterations" | "error";
  runId: string;
  summary?: string;
  error?: string;
}

/**
 * Run the autopilot loop.
 */
export async function run(params: RunnerParams): Promise<RunnerResult> {
  const { task, adapter, options, outDir } = params;
  const { context, manifest } = await initializeRun(task, options, outDir);

  const runState: RunState = {
    task,
    options,
    iterations: [],
  };

  let carrySummary = "";
  let nextWorkflowOverride: Workflow | null = null;

  try {
    for (let iteration = 1; iteration <= options.maxIterations; iteration++) {
      // Generate or use override workflow
      let workflow: Workflow;
      let workflowGenExecId: string | null = null;

      if (nextWorkflowOverride) {
        workflow = nextWorkflowOverride;
        nextWorkflowOverride = null;
      } else {
        const genResult = await generateWorkflow(
          task,
          carrySummary,
          iteration,
          adapter,
          context,
          manifest
        );
        workflow = genResult.workflow;
        workflowGenExecId = genResult.execId;
      }

      console.log(
        `\n[autopilot] Iteration ${iteration}: workflow=${workflow.id} steps=${workflow.steps.length}`
      );

      // Execute workflow steps
      const stepResults = await executeWorkflow(
        workflow,
        task,
        adapter,
        context,
        manifest,
        options.concurrency
      );

      // Record workflow dependencies in graph
      recordWorkflowEdges(workflow, stepResults, workflowGenExecId, manifest);

      // Check completion
      const completionResult = await checkCompletion(
        task,
        workflow,
        stepResults,
        iteration,
        adapter,
        context,
        manifest
      );

      // Record invokes edges from steps to completion check
      for (const step of stepResults) {
        if (step.sessionId) {
          addInvokesEdge(manifest, step.sessionId, completionResult.execId);
        }
      }

      await writeManifest(context, manifest);

      // Save iteration state
      runState.iterations.push({
        index: iteration,
        workflow,
        steps: stepResults,
        completion: completionResult.completion,
      });
      await writeRunState(context, runState);

      if (completionResult.completion.done) {
        finalizeRun(manifest);
        await writeManifest(context, manifest);
        console.log("\n[autopilot] Done.");
        console.log(completionResult.completion.summary || "(no summary)");
        return {
          status: "completed",
          runId: context.runId,
          summary: completionResult.completion.summary,
        };
      }

      console.log(`\n[autopilot] Not done: ${completionResult.completion.reason}`);

      if (completionResult.completion.nextWorkflow) {
        console.log("[autopilot] Reviewer provided next workflow; continuing.\n");
        nextWorkflowOverride = completionResult.completion.nextWorkflow;
      }

      carrySummary = buildCarrySummary(workflow, stepResults, completionResult.completion);
    }

    finalizeRun(manifest);
    await writeManifest(context, manifest);
    console.log(`\n[autopilot] Stopped after maxIterations=${options.maxIterations}`);

    return {
      status: "max-iterations",
      runId: context.runId,
    };
  } catch (error) {
    finalizeRun(manifest);
    await writeManifest(context, manifest);
    const message = error instanceof Error ? error.message : String(error);
    return {
      status: "error",
      runId: context.runId,
      error: message,
    };
  }
}

async function generateWorkflow(
  task: string,
  carrySummary: string,
  iteration: number,
  adapter: AgentAdapter,
  context: RunContext,
  manifest: RunManifest
): Promise<{ workflow: Workflow; execId: string }> {
  const prompt = buildWorkflowGenPrompt(task, iteration, carrySummary);
  const execId = allocateExecId(context);
  const label = `workflow-gen:iteration-${iteration}`;
  const startedAt = new Date().toISOString();

  const result = await adapter.execute({
    prompt,
    cwd: context.cwd,
    model: context.options.model,
    options: { unsafe: context.options.unsafe },
  });

  const finishedAt = new Date().toISOString();
  const artifacts = await writeExecArtifacts(
    context,
    execId,
    label,
    prompt,
    result.outputText,
    { sessionId: result.sessionId, usage: result.usage }
  );

  const entry = createExecEntry(
    execId,
    label,
    result.sessionId,
    result.status,
    startedAt,
    finishedAt,
    artifacts
  );
  addExecToManifest(manifest, entry);
  await writeManifest(context, manifest);

  const workflow = parseWorkflow(result.outputText);
  return { workflow, execId };
}

async function executeWorkflow(
  workflow: Workflow,
  task: string,
  adapter: AgentAdapter,
  context: RunContext,
  manifest: RunManifest,
  concurrency: number
): Promise<StepResult[]> {
  const completed = new Map<string, StepResult>();
  const pending = new Set(workflow.steps.map((s) => s.id));
  const running = new Set<string>();

  while (pending.size > 0) {
    const ready = findReadySteps(
      workflow.steps.filter((s) => pending.has(s.id)),
      new Set(completed.keys()),
      running
    );

    if (ready.length === 0 && running.size === 0) {
      throw new Error(`Workflow stuck: cannot resolve remaining steps`);
    }

    const slots = Math.max(1, concurrency) - running.size;
    const wave = ready.slice(0, Math.max(1, slots));

    for (const step of wave) {
      running.add(step.id);
    }

    const results = await Promise.all(
      wave.map((step) => executeStep(step, completed, task, adapter, context, manifest))
    );

    for (const result of results) {
      completed.set(result.stepId, result);
      pending.delete(result.stepId);
      running.delete(result.stepId);
      console.log(
        `[step:${result.stepId}] ${result.status} session=${result.sessionId}${
          result.error ? ` error=${result.error}` : ""
        }`
      );
    }
  }

  return workflow.steps.map((s) => completed.get(s.id)!);
}

async function executeStep(
  step: { id: string; goal: string; dependsOn?: string[] },
  completed: Map<string, StepResult>,
  task: string,
  adapter: AgentAdapter,
  context: RunContext,
  manifest: RunManifest
): Promise<StepResult> {
  const prompt = buildStepPrompt(step as any, completed, task);
  const execId = allocateExecId(context);
  const label = `step:${step.id}`;
  const startedAt = new Date().toISOString();

  try {
    const result = await adapter.execute({
      prompt,
      cwd: context.cwd,
      model: context.options.model,
      options: { unsafe: context.options.unsafe },
    });

    const finishedAt = new Date().toISOString();
    const artifacts = await writeExecArtifacts(
      context,
      execId,
      label,
      prompt,
      result.outputText,
      { sessionId: result.sessionId, usage: result.usage }
    );

    const entry = createExecEntry(
      execId,
      label,
      result.sessionId,
      result.status,
      startedAt,
      finishedAt,
      artifacts
    );
    addExecToManifest(manifest, entry);

    return {
      stepId: step.id,
      status: result.status,
      sessionId: result.sessionId,
      outputText: result.outputText,
      usage: result.usage,
    };
  } catch (error) {
    const finishedAt = new Date().toISOString();
    const errorMsg = error instanceof Error ? error.message : String(error);
    const artifacts = await writeExecArtifacts(
      context,
      execId,
      label,
      prompt,
      `Error: ${errorMsg}`,
      { error: errorMsg }
    );

    const entry = createExecEntry(
      execId,
      label,
      "",
      "failed",
      startedAt,
      finishedAt,
      artifacts
    );
    addExecToManifest(manifest, entry);

    return {
      stepId: step.id,
      status: "failed",
      sessionId: "",
      outputText: "",
      error: errorMsg,
    };
  }
}

async function checkCompletion(
  task: string,
  workflow: Workflow,
  results: StepResult[],
  iteration: number,
  adapter: AgentAdapter,
  context: RunContext,
  manifest: RunManifest
): Promise<{ completion: CompletionCheck; execId: string }> {
  const prompt = buildCompletionCheckPrompt(task, workflow, results, iteration);
  const execId = allocateExecId(context);
  const label = `completion-check:iteration-${iteration}`;
  const startedAt = new Date().toISOString();

  const result = await adapter.execute({
    prompt,
    cwd: context.cwd,
    model: context.options.model,
    options: { unsafe: context.options.unsafe },
  });

  const finishedAt = new Date().toISOString();
  const artifacts = await writeExecArtifacts(
    context,
    execId,
    label,
    prompt,
    result.outputText,
    { sessionId: result.sessionId, usage: result.usage }
  );

  const entry = createExecEntry(
    execId,
    label,
    result.sessionId,
    result.status,
    startedAt,
    finishedAt,
    artifacts
  );
  addExecToManifest(manifest, entry);

  const parsed = safeJsonParse(result.outputText);
  if (!parsed || typeof parsed !== "object") {
    return {
      completion: { done: false, reason: "Reviewer returned invalid JSON" },
      execId,
    };
  }

  const obj = parsed as Record<string, unknown>;
  if (obj.done === true) {
    return {
      completion: {
        done: true,
        summary: String(obj.summary ?? "Done."),
      },
      execId,
    };
  }

  const reason = String(obj.reason ?? "Not done.");
  const nextWorkflow = obj.nextWorkflow
    ? normalizeWorkflow(obj.nextWorkflow)
    : undefined;

  return {
    completion: { done: false, reason, nextWorkflow },
    execId,
  };
}

function recordWorkflowEdges(
  workflow: Workflow,
  results: StepResult[],
  workflowGenExecId: string | null,
  manifest: RunManifest
): void {
  const execByStep = new Map<string, string>();
  for (const result of results) {
    if (result.sessionId) {
      execByStep.set(result.stepId, result.sessionId);
    }
  }

  // Record dependsOn edges
  for (const step of workflow.steps) {
    const stepExecId = execByStep.get(step.id);
    if (!stepExecId || !step.dependsOn) continue;

    for (const dep of step.dependsOn) {
      const depExecId = execByStep.get(dep);
      if (depExecId) {
        addDependsOnEdge(manifest, depExecId, stepExecId);
      }
    }
  }

  // Record invokes edges from workflow gen to steps
  if (workflowGenExecId) {
    for (const result of results) {
      if (result.sessionId) {
        addInvokesEdge(manifest, workflowGenExecId, result.sessionId);
      }
    }
  }
}

async function writeRunState(context: RunContext, state: RunState): Promise<void> {
  const statePath = path.join(path.dirname(context.runDir), `${context.runId}.json`);
  await writeFile(statePath, JSON.stringify(state, null, 2), "utf8");
}
```

**Step 2: Run typecheck**

Run: `npm run typecheck`
Expected: Pass.

**Step 3: Commit**

```bash
git add src/runner.ts
git commit -m "feat: add main autopilot runner

- run() orchestrates workflow generation, execution, completion checking
- Parallel step execution with dependency resolution
- Full state persistence (manifest + run state)
- Graph construction for visualization"
```

---

## Task 9: CLI Entry Point

**Files:**
- Create: `src/index.ts`
- Modify: `package.json`

**Step 1: Create CLI entry point**

Create `src/index.ts`:

```typescript
#!/usr/bin/env node
/**
 * Autopilot CLI entry point.
 */

import process from "node:process";
import { run } from "./runner.js";
import { createAdapter } from "./adapters/factory.js";
import type { AdapterName } from "./adapters/types.js";
import type { RunOptions } from "./state/types.js";

const DEFAULT_MODEL = "claude-sonnet-4-20250514";
const DEFAULT_CONCURRENCY = 3;
const DEFAULT_MAX_ITERATIONS = 4;

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const parsed = parseArgs(args);

  if (!parsed) {
    printHelp();
    process.exit(1);
  }

  try {
    const adapter = await createAdapter(parsed.adapter);
    const result = await run({
      task: parsed.task,
      adapter,
      options: {
        adapter: parsed.adapter,
        model: parsed.model,
        concurrency: parsed.concurrency,
        maxIterations: parsed.maxIterations,
        unsafe: parsed.unsafe,
      },
      outDir: parsed.outDir,
    });

    console.log(`\n[autopilot] Run ID: ${result.runId}`);
    console.log(`[autopilot] Status: ${result.status}`);

    if (result.error) {
      console.error(`[autopilot] Error: ${result.error}`);
      process.exit(1);
    }
  } catch (error) {
    console.error(`[autopilot] Fatal error:`, error);
    process.exit(1);
  }
}

interface ParsedArgs {
  task: string;
  adapter: AdapterName;
  model: string;
  concurrency: number;
  maxIterations: number;
  unsafe: boolean;
  outDir: string;
}

function parseArgs(argv: string[]): ParsedArgs | null {
  let adapter: AdapterName = "claude";
  let model = DEFAULT_MODEL;
  let concurrency = DEFAULT_CONCURRENCY;
  let maxIterations = DEFAULT_MAX_ITERATIONS;
  let unsafe = false;
  let outDir = "runs/autopilot";
  const taskParts: string[] = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    if (arg === "--adapter" || arg === "-a") {
      const value = argv[++i];
      if (value === "claude" || value === "codex") {
        adapter = value;
      }
      continue;
    }
    if (arg.startsWith("--adapter=")) {
      const value = arg.slice("--adapter=".length);
      if (value === "claude" || value === "codex") {
        adapter = value;
      }
      continue;
    }

    if (arg === "--model" || arg === "-m") {
      model = argv[++i] ?? model;
      continue;
    }
    if (arg.startsWith("--model=")) {
      model = arg.slice("--model=".length);
      continue;
    }

    if (arg === "--concurrency" || arg === "-c") {
      concurrency = parseInt(argv[++i] ?? "", 10) || DEFAULT_CONCURRENCY;
      continue;
    }
    if (arg.startsWith("--concurrency=")) {
      concurrency = parseInt(arg.slice("--concurrency=".length), 10) || DEFAULT_CONCURRENCY;
      continue;
    }

    if (arg === "--max-iterations") {
      maxIterations = parseInt(argv[++i] ?? "", 10) || DEFAULT_MAX_ITERATIONS;
      continue;
    }
    if (arg.startsWith("--max-iterations=")) {
      maxIterations = parseInt(arg.slice("--max-iterations=".length), 10) || DEFAULT_MAX_ITERATIONS;
      continue;
    }

    if (arg === "--unsafe") {
      unsafe = true;
      continue;
    }

    if (arg === "--out-dir" || arg === "-o") {
      outDir = argv[++i] ?? outDir;
      continue;
    }
    if (arg.startsWith("--out-dir=")) {
      outDir = arg.slice("--out-dir=".length);
      continue;
    }

    if (arg === "--help" || arg === "-h") {
      return null;
    }

    taskParts.push(arg);
  }

  const task = taskParts.join(" ").trim();
  if (!task) {
    return null;
  }

  return {
    task,
    adapter,
    model,
    concurrency: Math.max(1, concurrency),
    maxIterations: Math.max(1, maxIterations),
    unsafe,
    outDir,
  };
}

function printHelp(): void {
  console.log(`
Usage:
  npx autopilot [options] "<task>"

Options:
  --adapter, -a <name>     Adapter: claude (default) or codex
  --model, -m <model>      Model to use (default: ${DEFAULT_MODEL})
  --concurrency, -c <n>    Max parallel steps (default: ${DEFAULT_CONCURRENCY})
  --max-iterations <n>     Max plan/execute cycles (default: ${DEFAULT_MAX_ITERATIONS})
  --unsafe                 Bypass approvals/sandbox (dangerous)
  --out-dir, -o <dir>      Output directory (default: runs/autopilot)
  --help, -h               Show this help

Examples:
  npx autopilot "Fix the authentication bug in src/auth.ts"
  npx autopilot --adapter codex "Implement user profile feature"
  npx autopilot --model claude-opus-4-20250514 --max-iterations 6 "Complex refactor"
`.trim());
}

main();
```

**Step 2: Update package.json**

Modify `package.json` to add the new script:

```json
{
  "name": "codex-autopilot",
  "private": true,
  "type": "module",
  "engines": {
    "node": ">=18"
  },
  "scripts": {
    "autopilot": "node --import tsx src/index.ts",
    "autopilot:legacy": "node --import tsx examples/codex-autopilot.ts",
    "viewer": "node --import tsx examples/run-viewer.ts --port 4141",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "test": "node --import tsx --test tests/*.test.ts"
  },
  "devDependencies": {
    "@types/node": "*",
    "tsx": "^4.19.0",
    "typescript": "^5.6.2"
  }
}
```

**Step 3: Run typecheck**

Run: `npm run typecheck`
Expected: Pass.

**Step 4: Commit**

```bash
git add src/index.ts package.json
git commit -m "feat: add CLI entry point

- src/index.ts: CLI with --adapter, --model, --concurrency options
- npm run autopilot now uses new modular code
- npm run autopilot:legacy preserves original implementation"
```

---

## Task 10: Port Skills to .claude/skills/

**Files:**
- Create: `.claude/skills/workflow-generator/SKILL.md`
- Create: `.claude/skills/task-executor/SKILL.md`
- Create: `.claude/skills/reviewer/SKILL.md`
- Create: `.claude/skills/tester/SKILL.md`
- Create: `.claude/skills/researcher/SKILL.md`

**Step 1: Create .claude/skills directory**

Run:
```bash
mkdir -p .claude/skills/workflow-generator .claude/skills/task-executor .claude/skills/reviewer .claude/skills/tester .claude/skills/researcher
```

**Step 2: Copy and adapt skills from .codex/skills/**

For each skill, copy the SKILL.md and update any Codex-specific references:

```bash
cp .codex/skills/workflow-generator/SKILL.md .claude/skills/workflow-generator/
cp .codex/skills/task-executor/SKILL.md .claude/skills/task-executor/
cp .codex/skills/reviewer/SKILL.md .claude/skills/reviewer/
cp .codex/skills/tester/SKILL.md .claude/skills/tester/
cp .codex/skills/researcher/SKILL.md .claude/skills/researcher/
```

**Step 3: Update skill references (if needed)**

Edit `.claude/skills/workflow-generator/SKILL.md` to change any Codex-specific model names or references. Replace:
- `gpt-5.2-codex` → `claude-sonnet-4-20250514`
- `codex-exec` → `claude-sdk`

**Step 4: Commit**

```bash
git add .claude/
git commit -m "feat: port skills to .claude/skills/

- Copy workflow-generator, task-executor, reviewer, tester, researcher
- Update model references for Claude compatibility
- Skills now work with both Claude and Codex adapters"
```

---

## Task 11: Integration Test

**Files:**
- Create: `tests/integration.test.ts`

**Step 1: Create integration test with mock adapter**

Create `tests/integration.test.ts`:

```typescript
import { describe, it } from "node:test";
import assert from "node:assert";
import { run } from "../src/runner.js";
import { MockAdapter } from "../src/adapters/mock.js";
import { rm, readFile } from "node:fs/promises";
import path from "node:path";
import os from "node:os";

describe("Integration: run() with MockAdapter", () => {
  it("completes a single-iteration workflow", async () => {
    const outDir = path.join(os.tmpdir(), `autopilot-test-${Date.now()}`);

    const adapter = new MockAdapter([
      // Workflow generation
      {
        sessionId: "wf-gen-1",
        outputText: JSON.stringify({
          version: 1,
          id: "test-workflow",
          steps: [{ id: "impl", type: "agent.run", goal: "implement feature" }],
        }),
        status: "succeeded",
      },
      // Step execution
      {
        sessionId: "step-impl",
        outputText: "Done: implemented the feature.",
        status: "succeeded",
      },
      // Completion check
      {
        sessionId: "completion-1",
        outputText: JSON.stringify({ done: true, summary: "All complete!" }),
        status: "succeeded",
      },
    ]);

    const result = await run({
      task: "Test task",
      adapter,
      options: {
        adapter: "claude",
        model: "test-model",
        concurrency: 1,
        maxIterations: 2,
        unsafe: false,
      },
      outDir,
    });

    assert.strictEqual(result.status, "completed");
    assert.strictEqual(result.summary, "All complete!");

    // Verify manifest was created
    const manifestPath = path.join(outDir, result.runId, "manifest.json");
    const manifest = JSON.parse(await readFile(manifestPath, "utf8"));
    assert.strictEqual(manifest.execs.length, 3); // wf-gen, step, completion

    // Cleanup
    await rm(outDir, { recursive: true, force: true });
  });

  it("handles multi-iteration workflow", async () => {
    const outDir = path.join(os.tmpdir(), `autopilot-test-${Date.now()}`);

    const adapter = new MockAdapter([
      // Iteration 1: workflow gen
      {
        sessionId: "wf-1",
        outputText: JSON.stringify({
          version: 1,
          id: "wf-1",
          steps: [{ id: "s1", type: "agent.run", goal: "step 1" }],
        }),
        status: "succeeded",
      },
      // Iteration 1: step
      { sessionId: "s1", outputText: "Step 1 done", status: "succeeded" },
      // Iteration 1: completion (not done)
      {
        sessionId: "c1",
        outputText: JSON.stringify({
          done: false,
          reason: "Need more work",
          nextWorkflow: {
            version: 1,
            id: "wf-2",
            steps: [{ id: "s2", type: "agent.run", goal: "step 2" }],
          },
        }),
        status: "succeeded",
      },
      // Iteration 2: step (using nextWorkflow)
      { sessionId: "s2", outputText: "Step 2 done", status: "succeeded" },
      // Iteration 2: completion (done)
      {
        sessionId: "c2",
        outputText: JSON.stringify({ done: true, summary: "Finally done" }),
        status: "succeeded",
      },
    ]);

    const result = await run({
      task: "Multi-iteration task",
      adapter,
      options: {
        adapter: "claude",
        model: "test",
        concurrency: 1,
        maxIterations: 3,
        unsafe: false,
      },
      outDir,
    });

    assert.strictEqual(result.status, "completed");

    // Cleanup
    await rm(outDir, { recursive: true, force: true });
  });
});
```

**Step 2: Run integration tests**

Run: `npm test`
Expected: All tests pass.

**Step 3: Commit**

```bash
git add tests/integration.test.ts
git commit -m "feat: add integration tests with MockAdapter

- Test single-iteration workflow completion
- Test multi-iteration with nextWorkflow from reviewer
- Verify manifest structure and state persistence"
```

---

## Summary

After completing all tasks, you will have:

1. **Modular type definitions** in `src/workflow/types.ts`, `src/adapters/types.ts`, `src/state/types.ts`
2. **Workflow parser** with validation and JSON extraction
3. **Prompt builders** for workflow gen, step execution, completion check
4. **Dependency resolution** with cycle detection
5. **Adapter interface** with mock, Claude stub, and Codex stub
6. **State management** for run persistence and artifacts
7. **Main runner** orchestrating the autopilot loop
8. **CLI entry point** with argument parsing
9. **Ported skills** in `.claude/skills/`
10. **Integration tests** verifying the full flow

**Next steps after this plan:**
- Implement real Claude SDK integration in `src/adapters/claude.ts`
- Extract Codex CLI logic into `src/adapters/codex.ts`
- Add more comprehensive error handling tests
- Document the new architecture in README.md
