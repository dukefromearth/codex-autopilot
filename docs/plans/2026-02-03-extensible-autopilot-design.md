# Extensible Autopilot Design

**Date**: 2026-02-03
**Status**: Draft
**Goal**: Make the autopilot runner extensible to support both Claude Code and Codex via an adapter pattern, with Claude Agent SDK as the primary interface.

---

## Overview

### Purpose

A TypeScript autopilot runner that orchestrates Claude Agent SDK calls to achieve autonomous task completion through iterative planning and execution, leveraging skills as the primary mechanism for predictable agent behavior.

### Core Concepts

**Skills as Context Injection** - When a step goal says "use the X skill", this triggers the skill's content to be injected into the agent's context. Skills provide:
- Structured instructions the agent follows
- Domain-specific knowledge and patterns
- Predictable, repeatable behavior from natural language tasks

**Workflow** - A DAG of steps generated by the LLM. Each step:
- References a skill to use
- Has dependencies on other steps
- Becomes an independent, resumable session

**Iteration Loop** - Plan → execute → review → replan until complete.

**Dumb Runner** - Schedules, passes outputs forward, records audit trail. Intelligence lives in skills and LLM.

### Learnings from Codex Autopilot

1. Skill-based decomposition creates emergent autonomy with minimal code
2. Each step as a resumable checkpoint enables HITL recovery
3. Prompt-based dataflow (pasting outputs forward) is powerful but needs guardrails
4. The reviewer skill is critical for self-correction
5. Structured workflow JSON provides predictability without over-constraining

---

## Architecture

### High-Level Components

```
┌─────────────────────────────────────────────────────────────┐
│                      Autopilot Runner                        │
│  (TypeScript - orchestration logic, no LLM intelligence)    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  Workflow   │───▶│   Step      │───▶│ Completion  │     │
│  │  Generator  │    │  Executor   │    │   Checker   │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│         │                  │                  │             │
│         ▼                  ▼                  ▼             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              Adapter Interface                       │   │
│  │  (abstracts SDK/CLI differences)                     │   │
│  └─────────────────────────────────────────────────────┘   │
│         │                                                   │
├─────────┼───────────────────────────────────────────────────┤
│         ▼                                                   │
│  ┌─────────────┐              ┌─────────────┐              │
│  │ Claude SDK  │              │  Codex SDK  │              │
│  │   Adapter   │              │   Adapter   │              │
│  └─────────────┘              └─────────────┘              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
         │                              │
         ▼                              ▼
┌─────────────────┐            ┌─────────────────┐
│ .claude/skills/ │            │ .codex/skills/  │
│  workflow-gen   │            │  workflow-gen   │
│  task-executor  │            │  task-executor  │
│  reviewer       │            │  reviewer       │
│  tester         │            │  tester         │
│  ...            │            │  ...            │
└─────────────────┘            └─────────────────┘
```

### Adapter Interface

```typescript
interface AgentAdapter {
  name: "claude" | "codex";

  // Core execution - prompt in, result out
  execute(params: ExecuteParams): Promise<ExecuteResult>;

  // Resume is just execute with a session context
  resume(sessionId: string, prompt: string, params?: Partial<ExecuteParams>): Promise<ExecuteResult>;

  // Optional: stream events as they occur
  stream?(params: ExecuteParams): AsyncIterable<AgentEvent>;
}

interface ExecuteParams {
  prompt: string;
  cwd: string;
  skillsPath: string;
  model?: string;
  options?: Record<string, unknown>;  // Adapter-specific options
}

interface ExecuteResult {
  sessionId: string;
  outputText: string;
  status: "succeeded" | "failed";
  usage?: { inputTokens: number; outputTokens: number };
}
```

### Run Artifacts Structure

```
runs/autopilot/{run-id}/
├── manifest.json           # Run metadata, execs, graph
├── {run-id}.json           # Full state with iterations
└── exec-{NNN}-{label}/
    ├── prompt.txt          # Input prompt
    ├── output.txt          # Final agent output
    ├── events.jsonl        # Streamed events (if available)
    └── metadata.json       # Session ID, timing, usage
```

---

## Execution Flow

### Main Loop

```
┌──────────────────────────────────────────────────────────────┐
│                        run(task)                             │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  for iteration = 1 to maxIterations:                         │
│                                                              │
│    ┌────────────────────────────────────────────────────┐   │
│    │ 1. GENERATE WORKFLOW                                │   │
│    │    prompt: "use the workflow-generator skill."      │   │
│    │    + task description                               │   │
│    │    + carry summary (if iteration > 1)               │   │
│    │    → returns: Workflow JSON                         │   │
│    └────────────────────────────────────────────────────┘   │
│                         │                                    │
│                         ▼                                    │
│    ┌────────────────────────────────────────────────────┐   │
│    │ 2. EXECUTE WORKFLOW                                 │   │
│    │    for each step in dependency order:               │   │
│    │      prompt: step.goal (e.g., "use the X skill.")   │   │
│    │      + overall task context                         │   │
│    │      + dependency outputs                           │   │
│    │    → returns: StepResult[] with outputs             │   │
│    └────────────────────────────────────────────────────┘   │
│                         │                                    │
│                         ▼                                    │
│    ┌────────────────────────────────────────────────────┐   │
│    │ 3. CHECK COMPLETION                                 │   │
│    │    prompt: "use the reviewer skill."                │   │
│    │    + task + workflow results                        │   │
│    │    → returns: { done: true, summary }               │   │
│    │            or { done: false, reason, nextWorkflow? }│   │
│    └────────────────────────────────────────────────────┘   │
│                         │                                    │
│              ┌──────────┴──────────┐                        │
│              │                     │                        │
│         done=true             done=false                    │
│              │                     │                        │
│              ▼                     ▼                        │
│         [return]           [continue loop]                  │
│                            carry summary forward            │
│                            use nextWorkflow if provided     │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### Step Execution (Parallel with Dependencies)

```typescript
async function executeWorkflow(
  workflow: Workflow,
  adapter: AgentAdapter,
  context: RunContext
): Promise<StepResult[]> {
  const completed = new Map<string, StepResult>();
  const pending = new Set(workflow.steps.map(s => s.id));

  while (pending.size > 0) {
    // Find steps whose dependencies are satisfied
    const ready = workflow.steps.filter(step =>
      pending.has(step.id) &&
      (step.dependsOn ?? []).every(dep => completed.has(dep))
    );

    // Execute ready steps in parallel (up to concurrency limit)
    const wave = ready.slice(0, context.concurrency);

    const results = await Promise.all(
      wave.map(step => executeStep(step, completed, adapter, context))
    );

    // Record results
    for (const result of results) {
      completed.set(result.stepId, result);
      pending.delete(result.stepId);
    }
  }

  return workflow.steps.map(s => completed.get(s.id)!);
}
```

### Step Prompt Construction

Each step prompt follows this pattern:

```
{step.goal}                           ← "use the task-executor skill. Fix the bug in..."

Overall task: {task}                  ← Full task description for context

Dependency outputs:                   ← Outputs from upstream steps
--- {dep.id} ({dep.status}) ---
{dep.outputText}

If you make code changes, run the most relevant checks/tests and report results.
Finish with a short 'Done' summary and any remaining risks.
```

---

## Data Flow & State Management

### State Layers

**1. Run State** (persisted to `{run-id}.json`)
```typescript
interface RunState {
  task: string;
  model: string;
  adapter: "claude" | "codex";
  iterations: Array<{
    index: number;
    workflow: Workflow;
    steps: StepResult[];
    completion: CompletionCheck;
  }>;
}
```

**2. Run Manifest** (persisted to `manifest.json`)
```typescript
interface RunManifest {
  runId: string;
  startedAt: string;
  finishedAt?: string;
  cwd: string;
  options: RunOptions;
  execs: ExecEntry[];
  graph: {
    nodes: GraphNode[];
    edges: GraphEdge[];
    warnings: string[];
  };
}
```

**3. Carry Summary** (in-memory, passed between iterations)
```typescript
function buildCarrySummary(
  workflow: Workflow,
  results: StepResult[],
  completion: CompletionCheck
): string {
  return `
Previous workflow: ${workflow.id}
Step statuses:
${results.map(r => `- ${r.stepId}: ${r.status} (session ${r.sessionId})`).join('\n')}
Reviewer: ${completion.done ? 'done' : `not done (${completion.reason})`}
  `.trim();
}
```

### Dataflow Between Steps

```
┌─────────────┐     outputText      ┌─────────────┐
│   step A    │ ──────────────────▶ │   step B    │
│ (research)  │                     │ (implement) │
└─────────────┘                     └─────────────┘
      │                                    │
      │ dependsOn: []                      │ dependsOn: ["A"]
      │                                    │
      ▼                                    ▼
┌─────────────────────────────────────────────────────────┐
│  Step B's prompt includes:                              │
│                                                         │
│  Dependency outputs:                                    │
│  --- A (succeeded) ---                                  │
│  {full text output from step A}                         │
└─────────────────────────────────────────────────────────┘
```

### Session Persistence for HITL

Every step execution creates a resumable checkpoint:

```
Step executes → sessionId captured → stored in manifest
                                            │
                                            ▼
                              User can later: adapter.resume(sessionId, "continue...")
```

---

## Error Handling

### Error Categories

| Category | Example | Handling Strategy |
|----------|---------|-------------------|
| **Adapter failure** | SDK connection error, auth failure | Fail fast, surface to user |
| **Step failure** | Agent returns error, non-zero exit | Record failure, continue workflow, let reviewer assess |
| **Workflow stuck** | Circular deps, missing step | Fail iteration, surface in manifest warnings |
| **Malformed output** | Workflow generator returns invalid JSON | Retry once with stricter prompt, then fail iteration |
| **Timeout** | Step runs too long | Configurable per-step timeout, treat as failure |
| **Iteration limit** | maxIterations reached without done=true | Graceful stop, preserve all state for manual resume |

### Step Failure Propagation

```typescript
async function executeStep(
  step: WorkflowStep,
  completed: Map<string, StepResult>,
  adapter: AgentAdapter,
  context: RunContext
): Promise<StepResult> {
  const failedDeps = (step.dependsOn ?? [])
    .filter(depId => completed.get(depId)?.status === "failed");

  if (failedDeps.length > 0 && context.failFast) {
    return {
      stepId: step.id,
      status: "skipped",
      sessionId: "",
      outputText: `Skipped: dependencies failed [${failedDeps.join(", ")}]`,
    };
  }

  try {
    const result = await adapter.execute({
      prompt: buildStepPrompt(step, completed, context),
      cwd: context.cwd,
      skillsPath: context.skillsPath,
    });

    return {
      stepId: step.id,
      status: result.status,
      sessionId: result.sessionId,
      outputText: result.outputText,
      usage: result.usage,
    };
  } catch (error) {
    return {
      stepId: step.id,
      status: "failed",
      sessionId: "",
      outputText: "",
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
```

### Recovery Mechanisms

1. **Reviewer-driven recovery** (automatic) - Reviewer can emit a `nextWorkflow` that retries or works around failures
2. **Manual resume** (HITL) - `autopilot resume <session-id> --prompt "Try a different approach"`
3. **Iteration state preservation** - All state written to disk after each step; can restart from last completed iteration

---

## Adapter Implementations

### Claude SDK Adapter

```typescript
import { query, ClaudeAgentOptions } from "claude-agent-sdk";

class ClaudeAdapter implements AgentAdapter {
  name = "claude" as const;

  async execute(params: ExecuteParams): Promise<ExecuteResult> {
    let sessionId = "";
    let outputText = "";
    let status: "succeeded" | "failed" = "succeeded";
    let usage = { inputTokens: 0, outputTokens: 0 };

    const options: ClaudeAgentOptions = {
      cwd: params.cwd,
      settingSources: ["project"],
      allowedTools: ["Skill", "Read", "Write", "Edit", "Bash", "Glob", "Grep"],
      model: params.model,
      permissionMode: params.options?.unsafe ? "bypassPermissions" : "acceptEdits",
    };

    for await (const message of query({ prompt: params.prompt, options })) {
      if (message.subtype === "init") {
        sessionId = message.data?.sessionId ?? "";
      }
      if (message.subtype === "success") {
        outputText = message.result ?? "";
        usage = {
          inputTokens: message.usage?.inputTokens ?? 0,
          outputTokens: message.usage?.outputTokens ?? 0,
        };
      }
      if (message.subtype === "error") {
        status = "failed";
        outputText = message.error ?? "Unknown error";
      }
    }

    return { sessionId, outputText, status, usage };
  }

  async resume(sessionId: string, prompt: string, params?: Partial<ExecuteParams>): Promise<ExecuteResult> {
    return this.execute({
      ...params,
      prompt,
      cwd: params?.cwd ?? process.cwd(),
      skillsPath: params?.skillsPath ?? ".claude/skills",
      options: { ...params?.options, resume: sessionId },
    });
  }
}
```

### Codex SDK Adapter (Sketch)

```typescript
import { CodexClient } from "@openai/codex-sdk";

class CodexAdapter implements AgentAdapter {
  name = "codex" as const;
  private client: CodexClient;

  constructor() {
    this.client = new CodexClient();
  }

  async execute(params: ExecuteParams): Promise<ExecuteResult> {
    const response = await this.client.exec({
      prompt: params.prompt,
      cwd: params.cwd,
      model: params.model ?? "gpt-5.2-codex",
      unsafe: params.options?.unsafe ?? false,
    });

    return {
      sessionId: response.threadId,
      outputText: response.output,
      status: response.exitCode === 0 ? "succeeded" : "failed",
      usage: response.usage,
    };
  }

  async resume(sessionId: string, prompt: string, params?: Partial<ExecuteParams>): Promise<ExecuteResult> {
    const response = await this.client.resume({
      threadId: sessionId,
      prompt,
    });

    return {
      sessionId: response.threadId,
      outputText: response.output,
      status: response.exitCode === 0 ? "succeeded" : "failed",
      usage: response.usage,
    };
  }
}
```

### Skills Path Convention

| Adapter | Skills Location | Loaded Via |
|---------|-----------------|------------|
| Claude | `.claude/skills/` | `settingSources: ["project"]` |
| Codex | `.codex/skills/` | Automatic (CLI convention) |

---

## Testing Strategy

### Test Layers

```
┌─────────────────────────────────────────────────────────────┐
│                     Integration Tests                        │
│        (Real adapter calls, real skills, real LLM)          │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Adapter Contract Tests                    │
│        (Mock LLM responses, verify adapter interface)        │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                      Unit Tests                              │
│        (Pure functions, no I/O)                             │
└─────────────────────────────────────────────────────────────┘
```

### Unit Tests

- Workflow parsing/validation
- Prompt construction
- Dependency graph resolution
- Carry summary building
- State serialization

### Adapter Contract Tests

- Mock SDK responses
- Verify adapters conform to interface
- Test error handling paths

### Integration Tests

- End-to-end with real LLM (run sparingly)
- Replay tests from captured runs

---

## Project Structure

```
codex-autopilot/
├── src/
│   ├── index.ts                 # CLI entry point
│   ├── runner.ts                # Main autopilot loop
│   ├── workflow/
│   │   ├── types.ts             # Workflow, Step, CompletionCheck types
│   │   ├── parser.ts            # Parse/validate workflow JSON
│   │   ├── executor.ts          # Execute workflow DAG
│   │   └── prompt.ts            # Build step prompts
│   ├── adapters/
│   │   ├── interface.ts         # AgentAdapter interface
│   │   ├── claude.ts            # Claude SDK adapter
│   │   ├── codex.ts             # Codex SDK adapter
│   │   └── factory.ts           # createAdapter()
│   ├── state/
│   │   ├── types.ts             # RunState, RunManifest types
│   │   ├── manifest.ts          # Write/update manifest.json
│   │   └── artifacts.ts         # Write per-exec artifacts
│   └── utils/
│       ├── json.ts              # Safe JSON parsing
│       ├── truncate.ts          # Output truncation
│       └── graph.ts             # Graph helpers
├── .claude/skills/              # Claude-compatible skills
├── .codex/skills/               # Codex-compatible skills
├── tests/
├── runs/
└── package.json
```

---

## Migration Path

| Phase | Description |
|-------|-------------|
| **1. Extract types** | Pull types into `src/workflow/types.ts` and `src/state/types.ts` |
| **2. Build adapter interface** | Create `AgentAdapter` in `src/adapters/interface.ts` |
| **3. Wrap existing Codex logic** | Move `codexExec()` into `CodexAdapter` |
| **4. Implement Claude adapter** | Build `ClaudeAdapter` using Claude Agent SDK |
| **5. Refactor runner** | Update `run()` to accept an adapter |
| **6. Port skills** | Copy/adapt `.codex/skills/` to `.claude/skills/` |
| **7. Add tests** | Unit tests, adapter contract tests |
| **8. Validate** | Integration test with both adapters |

---

## CLI Interface

```bash
# Run with Claude (default)
npx autopilot "Fix the authentication bug in src/auth.ts"

# Run with Codex
npx autopilot --adapter codex "Fix the authentication bug"

# Additional options
npx autopilot \
  --adapter claude \
  --model claude-sonnet-4-20250514 \
  --max-iterations 4 \
  --concurrency 2 \
  "Implement the new feature"

# Resume a session
npx autopilot resume <session-id> --prompt "Try a different approach"
```

---

## Summary

This design preserves the core autopilot behaviors:

1. **Compile task → DAG** via workflow-generator skill
2. **Execute with parallelism** respecting dependencies
3. **Resumable sessions** for HITL intervention
4. **Plan → run → replan loop** via reviewer skill
5. **Dumb runner** with intelligence in skills
6. **Full audit trail** in run artifacts

While enabling:

- **Adapter abstraction** for Claude SDK and Codex SDK
- **Native SDK integration** (no subprocess spawning for Claude)
- **Portable skills** across both platforms
- **Cleaner architecture** with separated concerns
